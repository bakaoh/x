package main

import (
	"bytes"
	"fmt"
	"html/template"
	"strings"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin_go "github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/pseudomuto/protokit"
)

var (
	mergeTemplate = template.Must(template.New("merge").Parse(
		`// Code generated by protoc-gen-gomerge. DO NOT EDIT.
package {{ .Package }}

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

type MergeClient interface {
{{range $i := .Methods}}	{{ $i.Signature }}
{{end}}}

type mergeClient struct {
	cc *grpc.ClientConn
}

func NewMergeClient(cc *grpc.ClientConn) MergeClient {
	return &mergeClient{cc}
}
{{range $i := .Methods}}
func (c *mergeClient) {{ $i.Signature }} {
	out := new({{ $i.OutType }})
	err := c.cc.Invoke(ctx, "{{ $i.SName }}", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}
{{end}}`))
)

var typeNameToObject map[string]*protokit.Descriptor

type methodObject struct {
	SName     string
	OutType   string
	Signature string
}

// Merge ...
func Merge(resp *plugin_go.CodeGeneratorResponse, descriptors []*protokit.FileDescriptor) {
	allMethods := []*methodObject{}
	allPackage := ""
	for _, d := range descriptors {
		if allPackage == "" {
			allPackage = d.GetPackage()
		} else if allPackage != d.GetPackage() {
			errMsg := fmt.Sprintf("inconsistent package names: %s, %s", allPackage, d.GetPackage())
			resp.Error = &errMsg
			return
		}

		for _, s := range d.FileDescriptorProto.Service {
			origServName := s.GetName()
			fullServName := origServName
			if pkg := d.GetPackage(); pkg != "" {
				fullServName = pkg + "." + fullServName
			}

			for _, method := range s.Method {
				if method.GetServerStreaming() || method.GetClientStreaming() {
					errMsg := fmt.Sprintf("streaming is not supported: %s", method.GetName())
					resp.Error = &errMsg
					return
				}

				allMethods = append(
					allMethods,
					&methodObject{
						fmt.Sprintf("/%s/%s", fullServName, method.GetName()),
						TypeName(typeNameToObject[method.GetOutputType()]),
						generateClientSignature(CamelCase(origServName), method),
					},
				)
			}
		}
	}

	w := bytes.NewBuffer(nil)
	if err := mergeTemplate.Execute(w, struct {
		Package string
		Methods []*methodObject
	}{allPackage, allMethods}); err == nil {
		resp.File = append(resp.File, &plugin_go.CodeGeneratorResponse_File{
			Name:    proto.String("merge.pb.go"),
			Content: proto.String(w.String()),
		})
	}
}

// generateClientSignature returns the client-side signature for a method.
func generateClientSignature(servName string, method *descriptor.MethodDescriptorProto) string {
	origMethName := method.GetName()
	methName := CamelCase(origMethName)
	reqArg := ", in *" + TypeName(typeNameToObject[method.GetInputType()])
	if method.GetClientStreaming() {
		reqArg = ""
	}
	respName := "*" + TypeName(typeNameToObject[method.GetOutputType()])
	if method.GetServerStreaming() || method.GetClientStreaming() {
		respName = servName + "_" + CamelCase(origMethName) + "Client"
	}
	return fmt.Sprintf("%s(ctx context.Context%s, opts ...grpc.CallOption) (%s, error)", methName, reqArg, respName)
}

// TypeName ...
func TypeName(obj *protokit.Descriptor) string {
	return CamelCaseSlice(DescriptorTypeName(obj))
}

// BuildTypeNameMap builds the map from fully qualified type names to objects.
// The key names for the map come from the input data, which puts a period at the beginning.
// It should be called after SetPackageNames and before GenerateAllFiles.
func BuildTypeNameMap(descriptors []*protokit.FileDescriptor) {
	typeNameToObject = make(map[string]*protokit.Descriptor)
	for _, f := range descriptors {
		// The names in this loop are defined by the proto world, not us, so the
		// package name may be empty.  If so, the dotted package name of X will
		// be ".X"; otherwise it will be ".pkg.X".
		dottedPkg := "." + f.GetPackage()
		if dottedPkg != "." {
			dottedPkg += "."
		}
		// for _, enum := range f.Enums {
		// 	name := dottedPkg + dottedSlice(enum.TypeName())
		// 	typeNameToObject[name] = enum
		// }
		for _, desc := range f.Messages {
			name := dottedPkg + dottedSlice(DescriptorTypeName(desc))
			typeNameToObject[name] = desc
		}
	}
}

// DescriptorTypeName returns the elements of the dotted type name.
// The package name is not part of this name.
func DescriptorTypeName(d *protokit.Descriptor) []string {
	n := 0
	for parent := d; parent != nil; parent = parent.Parent {
		n++
	}
	s := make([]string, n)
	for parent := d; parent != nil; parent = parent.Parent {
		n--
		s[n] = parent.GetName()
	}
	return s
}

// CamelCaseSlice is like CamelCase, but the argument is a slice of strings to
// be joined with "_".
func CamelCaseSlice(elem []string) string { return CamelCase(strings.Join(elem, "_")) }

// CamelCase returns the CamelCased name.
// If there is an interior underscore followed by a lower case letter,
// drop the underscore and convert the letter to upper case.
// There is a remote possibility of this rewrite causing a name collision,
// but it's so remote we're prepared to pretend it's nonexistent - since the
// C++ generator lowercases names, it's extremely unlikely to have two fields
// with different capitalizations.
// In short, _my_field_name_2 becomes XMyFieldName_2.
func CamelCase(s string) string {
	if s == "" {
		return ""
	}
	t := make([]byte, 0, 32)
	i := 0
	if s[0] == '_' {
		// Need a capital letter; drop the '_'.
		t = append(t, 'X')
		i++
	}
	// Invariant: if the next letter is lower case, it must be converted
	// to upper case.
	// That is, we process a word at a time, where words are marked by _ or
	// upper case letter. Digits are treated as words.
	for ; i < len(s); i++ {
		c := s[i]
		if c == '_' && i+1 < len(s) && isASCIILower(s[i+1]) {
			continue // Skip the underscore in s.
		}
		if isASCIIDigit(c) {
			t = append(t, c)
			continue
		}
		// Assume we have a letter now - if not, it's a bogus identifier.
		// The next word is a sequence of characters that must start upper case.
		if isASCIILower(c) {
			c ^= ' ' // Make it a capital letter.
		}
		t = append(t, c) // Guaranteed not lower case.
		// Accept lower case sequence that follows.
		for i+1 < len(s) && isASCIILower(s[i+1]) {
			i++
			t = append(t, s[i])
		}
	}
	return string(t)
}

// Is c an ASCII lower-case letter?
func isASCIILower(c byte) bool {
	return 'a' <= c && c <= 'z'
}

// Is c an ASCII digit?
func isASCIIDigit(c byte) bool {
	return '0' <= c && c <= '9'
}

func dottedSlice(elem []string) string { return strings.Join(elem, ".") }
